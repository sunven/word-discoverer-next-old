{"version":3,"file":"import.js","mappings":";;;;;;;;;;;;;;;;;;;AAAO;AACP,sBAAsB,mCAAmC;AACzD,0CAA0C,wBAAwB;AAClE,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAiD;AACpF;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEO;AACP;AACA;AACA,kDAAkD;AAClD,6FAA6F;AAC7F,mEAAmE;AACnE;AACA,+BAA+B,eAAe;AAC9C;AACA;;AAEO;AACP;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,uBAAuB,MAAM;AAC7B;AACA,GAAG;AACH;;;;;;;SC3HA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;ACNgE;;AAEhE;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,wBAAwB;AACtC;AACA,0BAA0B;AAC1B,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uDAAc;AAC1D;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA,mBAAmB,aAAa;AAChC,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,6DAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","sources":["webpack:///./src/common_lib.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/import.js"],"sourcesContent":["export function request_unhighlight(lemma) {\n  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\n    chrome.tabs.sendMessage(tabs[0].id, { wdm_unhighlight: lemma })\n  })\n}\n\nexport function make_id_suffix(text) {\n  var before = btoa(text)\n  var after = before.replace(/\\+/g, '_').replace(/\\//g, '-').replace(/=/g, '_')\n  return after\n}\n\nexport function sync_if_needed() {\n  var req_keys = ['wd_last_sync', 'wd_gd_sync_enabled', 'wd_last_sync_error']\n  chrome.storage.local.get(req_keys, function (result) {\n    var wd_last_sync = result.wd_last_sync\n    var wd_gd_sync_enabled = result.wd_gd_sync_enabled\n    var wd_last_sync_error = result.wd_last_sync_error\n    if (!wd_gd_sync_enabled || wd_last_sync_error != null) {\n      return\n    }\n    var cur_date = new Date()\n    var mins_passed = (cur_date.getTime() - wd_last_sync) / (60 * 1000)\n    var sync_period_mins = 30\n    if (mins_passed >= sync_period_mins) {\n      chrome.runtime.sendMessage({ wdm_request: 'gd_sync', interactive_mode: false })\n    }\n  })\n}\n\nexport function add_lexeme(lexeme, result_handler) {\n  var req_keys = [\n    'words_discoverer_eng_dict',\n    'wd_idioms',\n    'wd_user_vocabulary',\n    'wd_user_vocab_added',\n    'wd_user_vocab_deleted',\n  ]\n  chrome.storage.local.get(req_keys, function (result) {\n    var dict_words = result.words_discoverer_eng_dict\n    var dict_idioms = result.wd_idioms\n    var user_vocabulary = result.wd_user_vocabulary\n    var wd_user_vocab_added = result.wd_user_vocab_added\n    var wd_user_vocab_deleted = result.wd_user_vocab_deleted\n    if (lexeme.length > 100) {\n      result_handler('bad', undefined)\n      return\n    }\n    lexeme = lexeme.toLowerCase()\n    lexeme = lexeme.trim()\n    if (!lexeme) {\n      result_handler('bad', undefined)\n      return\n    }\n\n    var key = lexeme\n    if (dict_words.hasOwnProperty(lexeme)) {\n      var wf = dict_words[lexeme]\n      if (wf) {\n        key = wf[0]\n      }\n    } else if (dict_idioms.hasOwnProperty(lexeme)) {\n      var wf = dict_idioms[lexeme]\n      if (wf && wf != -1) {\n        key = wf\n      }\n    }\n\n    if (user_vocabulary.hasOwnProperty(key)) {\n      result_handler('exists', key)\n      return\n    }\n\n    var new_state = { wd_user_vocabulary: user_vocabulary }\n\n    user_vocabulary[key] = 1\n    if (typeof wd_user_vocab_added !== 'undefined') {\n      wd_user_vocab_added[key] = 1\n      new_state['wd_user_vocab_added'] = wd_user_vocab_added\n    }\n    if (typeof wd_user_vocab_deleted !== 'undefined') {\n      delete wd_user_vocab_deleted[key]\n      new_state['wd_user_vocab_deleted'] = wd_user_vocab_deleted\n    }\n\n    chrome.storage.local.set(new_state, function () {\n      sync_if_needed()\n      result_handler('ok', key)\n    })\n  })\n}\n\nexport function make_hl_style(hl_params) {\n  if (!hl_params.enabled) return undefined\n  let result = ''\n  if (hl_params.bold) result += 'font-weight:bold;'\n  if (hl_params.useBackground) result += 'background-color:' + hl_params.backgroundColor + ';'\n  if (hl_params.useColor) result += 'color:' + hl_params.color + ';'\n  if (!result) return undefined\n  result += 'font-size:inherit;display:inline;'\n  return result\n}\n\nexport function localizeHtmlPage() {\n  //Localize by replacing __MSG_***__ meta tags\n  var objects = document.getElementsByTagName('html')\n  for (var j = 0; j < objects.length; j++) {\n    var obj = objects[j]\n    var valStrH = obj.innerHTML.toString()\n    var valNewH = valStrH.replace(/__MSG_(\\w+)__/g, function (match, v1) {\n      return v1 ? chrome.i18n.getMessage(v1) : ''\n    })\n    if (valNewH != valStrH) {\n      obj.innerHTML = valNewH\n    }\n  }\n}\n\nexport function spformat(src) {\n  var args = Array.prototype.slice.call(arguments, 1)\n  return src.replace(/{(\\d+)}/g, function (match, number) {\n    return typeof args[number] != 'undefined' ? args[number] : match\n  })\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { localizeHtmlPage, sync_if_needed } from \"./common_lib\";\n\nfunction parse_vocabulary(text) {\n  const lines = text.split(\"\\n\");\n  const found = [];\n  for (let i = 0; i < lines.length; ++i) {\n    let word = lines[i];\n    if (i + 1 === lines.length && word.length <= 1) break;\n    if (word.slice(-1) === \"\\r\") {\n      word = word.slice(0, -1);\n    }\n    found.push(word);\n  }\n  return found;\n}\n\nfunction add_new_words(new_words) {\n  chrome.storage.local.get(\n    [\"wd_user_vocabulary\", \"wd_user_vocab_added\", \"wd_user_vocab_deleted\"],\n    function (result) {\n      const user_vocabulary = result.wd_user_vocabulary;\n      const { wd_user_vocab_added } = result;\n      const { wd_user_vocab_deleted } = result;\n      let num_added = 0;\n      const new_state = { wd_user_vocabulary: user_vocabulary };\n      for (let i = 0; i < new_words.length; ++i) {\n        const word = new_words[i];\n        if (!user_vocabulary.hasOwnProperty(word)) {\n          user_vocabulary[word] = 1;\n          ++num_added;\n          if (typeof wd_user_vocab_added !== \"undefined\") {\n            wd_user_vocab_added[word] = 1;\n            new_state.wd_user_vocab_added = wd_user_vocab_added;\n          }\n          if (typeof wd_user_vocab_deleted !== \"undefined\") {\n            delete wd_user_vocab_deleted[word];\n            new_state.wd_user_vocab_deleted = wd_user_vocab_deleted;\n          }\n        }\n      }\n      if (num_added) {\n        chrome.storage.local.set(new_state, sync_if_needed);\n      }\n      const num_skipped = new_words.length - num_added;\n      document.getElementById(\"addedInfo\").textContent =\n        `Added ${num_added} new words.`;\n      document.getElementById(\"skippedInfo\").textContent =\n        `Skipped ${num_skipped} existing words.`;\n    },\n  );\n}\n\nfunction process_change() {\n  const inputElem = document.getElementById(\"doLoadVocab\");\n  const baseName = inputElem.files[0].name;\n  document.getElementById(\"fnamePreview\").textContent = baseName;\n}\n\nfunction process_submit() {\n  // TODO add a radio button with two options: 1. merge vocabulary [default]; 2. replace vocabulary\n  const inputElem = document.getElementById(\"doLoadVocab\");\n  const file = inputElem.files[0];\n  const reader = new FileReader();\n  reader.onload = function (e) {\n    const new_words = parse_vocabulary(reader.result);\n    add_new_words(new_words);\n  };\n  reader.readAsText(file);\n}\n\nfunction init_controls() {\n  window.onload = function () {\n    localizeHtmlPage();\n    document\n      .getElementById(\"vocabSubmit\")\n      .addEventListener(\"click\", process_submit);\n    document\n      .getElementById(\"doLoadVocab\")\n      .addEventListener(\"change\", process_change);\n  };\n}\n\ninit_controls();\n"],"names":[],"sourceRoot":""}