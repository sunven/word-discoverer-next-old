{"version":3,"file":"black_white.js","mappings":";;;;;;;;;;;;;;;;;;;AAAO;AACP,sBAAsB,mCAAmC;AACzD,0CAA0C,wBAAwB;AAClE,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,qBAAqB;AACjC,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA,kDAAkD;AAClD;AACA,kCAAkC,2BAA2B;AAC7D,6CAA6C,iBAAiB;AAC9D;AACA,+BAA+B,eAAe;AAC9C;AACA;;AAEO;AACP;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,uBAAuB,MAAM;AAC7B;AACA,GAAG;AACH;;;;;;;SCvIA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;ACN6C;;AAE7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC,cAAc,wBAAwB;AACtC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAc;AACvD;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,CAAC","sources":["webpack:///./src/common_lib.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/black_white.js"],"sourcesContent":["export function request_unhighlight(lemma) {\n  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\n    chrome.tabs.sendMessage(tabs[0].id, { wdm_unhighlight: lemma })\n  })\n}\n\nexport function make_id_suffix(text) {\n  const before = btoa(text)\n  const after = before\n    .replace(/\\+/g, '_')\n    .replace(/\\//g, '-')\n    .replace(/=/g, '_')\n  return after\n}\n\nexport function sync_if_needed() {\n  const req_keys = ['wd_last_sync', 'wd_gd_sync_enabled', 'wd_last_sync_error']\n  chrome.storage.sync.get(req_keys, function (result) {\n    const { wd_last_sync } = result\n    const { wd_gd_sync_enabled } = result\n    const { wd_last_sync_error } = result\n    if (!wd_gd_sync_enabled || wd_last_sync_error != null) {\n      return\n    }\n    const cur_date = new Date()\n    const mins_passed = (cur_date.getTime() - wd_last_sync) / (60 * 1000)\n    const sync_period_mins = 30\n    if (mins_passed >= sync_period_mins) {\n      chrome.runtime.sendMessage({\n        wdm_request: 'gd_sync',\n        interactive_mode: false,\n      })\n    }\n  })\n}\n\nexport function add_lexeme(lexeme, result_handler) {\n  const req_keys = [\n    'wd_user_vocabulary',\n    'wd_user_vocab_added',\n    'wd_user_vocab_deleted',\n  ]\n  chrome.storage.sync.get(req_keys, function (result) {\n    const user_vocabulary = result.wd_user_vocabulary\n    const { wd_user_vocab_added } = result\n    const { wd_user_vocab_deleted } = result\n    chrome.storage.local.get(\n      ['words_discoverer_eng_dict', 'wd_idioms'],\n      function (result1) {\n        const dict_words = result1.words_discoverer_eng_dict\n        const dict_idioms = result1.wd_idioms\n\n        if (lexeme.length > 100) {\n          result_handler('bad', undefined)\n          return\n        }\n        lexeme = lexeme.toLowerCase()\n        lexeme = lexeme.trim()\n        if (!lexeme) {\n          result_handler('bad', undefined)\n          return\n        }\n\n        let key = lexeme\n        if (dict_words.hasOwnProperty(lexeme)) {\n          const wf = dict_words[lexeme]\n          if (wf) {\n            const [first] = wf\n            key = first\n          }\n        } else if (dict_idioms.hasOwnProperty(lexeme)) {\n          const wf = dict_idioms[lexeme]\n          if (wf && wf !== -1) {\n            key = wf\n          }\n        }\n\n        if (user_vocabulary.hasOwnProperty(key)) {\n          result_handler('exists', key)\n          return\n        }\n\n        const new_state = { wd_user_vocabulary: user_vocabulary }\n\n        user_vocabulary[key] = 1\n        if (typeof wd_user_vocab_added !== 'undefined') {\n          wd_user_vocab_added[key] = 1\n          new_state.wd_user_vocab_added = wd_user_vocab_added\n        }\n        if (typeof wd_user_vocab_deleted !== 'undefined') {\n          delete wd_user_vocab_deleted[key]\n          new_state.wd_user_vocab_deleted = wd_user_vocab_deleted\n        }\n\n        chrome.storage.sync.set(new_state, function () {\n          sync_if_needed()\n          result_handler('ok', key)\n        })\n      },\n    )\n  })\n}\n\nexport function make_hl_style(hl_params) {\n  if (!hl_params.enabled) return undefined\n  let result = ''\n  if (hl_params.bold) result += 'font-weight:bold;'\n  if (hl_params.useBackground)\n    result += `background-color:${hl_params.backgroundColor};`\n  if (hl_params.useColor) result += `color:${hl_params.color};`\n  if (!result) return undefined\n  result += 'font-size:inherit;display:inline;'\n  return result\n}\n\nexport function localizeHtmlPage() {\n  // Localize by replacing __MSG_***__ meta tags\n  const objects = document.getElementsByTagName('html')\n  for (let j = 0; j < objects.length; j++) {\n    const obj = objects[j]\n    const valStrH = obj.innerHTML.toString()\n    const valNewH = valStrH.replace(/__MSG_(\\w+)__/g, function (match, v1) {\n      return v1 ? chrome.i18n.getMessage(v1) : ''\n    })\n    if (valNewH !== valStrH) {\n      obj.innerHTML = valNewH\n    }\n  }\n}\n\nexport function spformat(src, ...args) {\n  // const args = Array.prototype.slice.call(arguments, 1)\n  return src.replace(/{(\\d+)}/g, function (match, number) {\n    return typeof args[number] !== 'undefined' ? args[number] : match\n  })\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { sync_if_needed } from './common_lib'\n\nconst list_section_names = {\n  wd_black_list: 'blackListSection',\n  wd_white_list: 'whiteListSection',\n  wd_user_vocabulary: 'vocabularySection',\n}\n\nfunction process_delete_simple(list_name, key) {\n  chrome.storage.sync.get([list_name], function (result) {\n    const user_list = result[list_name]\n    delete user_list[key]\n    chrome.storage.sync.set({ [list_name]: user_list })\n    show_user_list(list_name, user_list)\n  })\n}\n\nfunction process_delete_vocab_entry(key) {\n  chrome.storage.sync.get(\n    ['wd_user_vocabulary', 'wd_user_vocab_added', 'wd_user_vocab_deleted'],\n    function (result) {\n      const user_vocabulary = result.wd_user_vocabulary\n      const { wd_user_vocab_added } = result\n      const { wd_user_vocab_deleted } = result\n      const new_state = { wd_user_vocabulary: user_vocabulary }\n      delete user_vocabulary[key]\n      if (typeof wd_user_vocab_added !== 'undefined') {\n        delete wd_user_vocab_added[key]\n        new_state.wd_user_vocab_added = wd_user_vocab_added\n      }\n      if (typeof wd_user_vocab_deleted !== 'undefined') {\n        wd_user_vocab_deleted[key] = 1\n        new_state.wd_user_vocab_deleted = wd_user_vocab_deleted\n      }\n      chrome.storage.sync.set(new_state, sync_if_needed)\n      show_user_list('wd_user_vocabulary', user_vocabulary)\n    },\n  )\n}\n\nfunction create_button(list_name, text) {\n  const result = document.createElement('button')\n  result.setAttribute('class', 'deleteButton')\n  result.expression_text = text\n  if (list_name === 'wd_user_vocabulary') {\n    result.addEventListener('click', function () {\n      process_delete_vocab_entry(this.expression_text)\n    })\n  } else {\n    result.addEventListener('click', function () {\n      process_delete_simple(list_name, this.expression_text)\n    })\n  }\n  const img = document.createElement('img')\n  img.setAttribute('src', '../assets/delete.png')\n  result.appendChild(img)\n  return result\n}\n\nfunction create_label(text) {\n  const result = document.createElement('span')\n  result.setAttribute('class', 'wordText')\n  result.textContent = text\n  return result\n}\n\nfunction show_user_list(list_name, user_list) {\n  const keys = []\n  Object.keys(user_list).forEach((key) => {\n    if (user_list.hasOwnProperty(key)) {\n      keys.push(key)\n    }\n  })\n  const section_name = list_section_names[list_name]\n  const div_element = document.getElementById(section_name)\n  while (div_element.firstChild) {\n    div_element.removeChild(div_element.firstChild)\n  }\n  if (!keys.length) {\n    div_element.appendChild(\n      create_label(chrome.i18n.getMessage('emptyListError')),\n    )\n    div_element.appendChild(document.createElement('br'))\n    return\n  }\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    if (key.indexOf(\"'\") !== -1 || key.indexOf('\"') !== -1) {\n      continue\n    }\n    div_element.appendChild(create_button(list_name, key))\n    div_element.appendChild(create_label(key))\n    div_element.appendChild(document.createElement('br'))\n  }\n}\n\nfunction process_display() {\n  let list_name = ''\n  // TODO replace this clumsy logic by adding a special \"data-list-name\" attribute and renaming all 3 tags to \"userListSection\"\n  if (document.getElementById('blackListSection')) {\n    list_name = 'wd_black_list'\n  } else if (document.getElementById('whiteListSection')) {\n    list_name = 'wd_white_list'\n  } else {\n    list_name = 'wd_user_vocabulary'\n  }\n\n  chrome.storage.sync.get([list_name], function (result) {\n    const user_list = result[list_name]\n    show_user_list(list_name, user_list)\n  })\n}\n\ndocument.addEventListener('DOMContentLoaded', function (event) {\n  process_display()\n})\n"],"names":[],"sourceRoot":""}